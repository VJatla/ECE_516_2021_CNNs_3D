# -*- coding: utf-8 -*-
"""CNN_3D.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/VJatla/ECE_516_2021_CNNs_3D/blob/main/CNN_3D.ipynb
"""

from google.colab.patches import cv2_imshow
from google.colab import drive

# Libraries
import time
import numpy as np
import sklearn as skl
import cv2
from matplotlib import pyplot as plt

# Torch modules
# PyTorch libraries and modules
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.optim import *
from torchsummary import summary

from sklearn.metrics import accuracy_score

import pdb
import sys
import os
import mediapy as media


# ??? <--- Here write code to copy to the numpy arrays to persons home directory.
# Here is the link
# wget https://ece46medsrv.ece.unm.edu/ECE533_2021_hwk_wnw_tnt_data.zip


# Checking writing nowriting samples <- Writing
X = np.load(f"{data_dir}/ECE533_2021_hwk_wnw_tnt_data/writing_nowriting_gray_X.npy")
Y = np.load(f"{data_dir}/ECE533_2021_hwk_wnw_tnt_data/writing_nowriting_gray_y.npy")

# Talking
X = np.load(f"{data_dir}/ECE533_2021_hwk_wnw_tnt_data/talking_notalking_gray_X.npy")
Y = np.load(f"{data_dir}/ECE533_2021_hwk_wnw_tnt_data/talking_notalking_gray_y.npy")


# Creating training and testing sets
X_train = X[0:120]
X_test = X[120:158]

Y_train = Y[0:120]
Y_test  = Y[120:158]
Y_train = Y_train.reshape(-1,1)
Y_test = Y_test.reshape(-1,1)


# Reshape to match expectation of pytorch (N, C_in, D_in, H, W)
# Swap axes channels with depth
# NOTE: Reshape fucntion scrambled the image. So I used three swaps to get it 
# to desired shape.
# Training set
X_train = np.swapaxes(X_train, 1, 4) # (N, D_in, H, W, C_in) -> (N, C_in, H, W, D_in)
X_train = np.swapaxes(X_train, 2, 4) # (N, C_in, H, W, D_in) -> (N, C_in, D_in, W, H)
X_train = np.swapaxes(X_train, 3, 4) # (N, C_in, D_in, W, H) -> (N, C_in, D_in, H, W)
X_test = np.swapaxes(X_test, 1, 4) # (N, D_in, H, W, C_in) -> (N, C_in, H, W, D_in)
X_test = np.swapaxes(X_test, 2, 4) # (N, C_in, H, W, D_in) -> (N, C_in, D_in, W, H)
X_test = np.swapaxes(X_test, 3, 4) # (N, C_in, D_in, W, H) -> (N, C_in, D_in, H, W)


# Loading numpy arrays to torch
X_train_torch = torch.from_numpy(X_train).float()
X_test_torch = torch.from_numpy(X_test).float()
Y_train_torch = torch.from_numpy(Y_train).float()
Y_test_torch = torch.from_numpy(Y_test).float()


# Creating training and testing loaders
batch_size = 4


# Creating training and testing sets using pytorch DataSet class
train = torch.utils.data.TensorDataset(X_train_torch, Y_train_torch)
test = torch.utils.data.TensorDataset(X_test_torch, Y_test_torch)


# Dataloader
train_loader = torch.utils.data.DataLoader(train, batch_size = batch_size, shuffle = True)
test_loader = torch.utils.data.DataLoader(test, batch_size = batch_size, shuffle = True)


# A simple 3D-CNN network
num_classes = 2


# Create CNN Model
class CNNModel(nn.Module):
    def __init__(self):
        super(CNNModel, self).__init__()
        
        self.conv_layer1 = self._conv_layer_set(1, 2)
        self.conv_layer2 = self._conv_layer_set(2, 4)
        self.fc1 = nn.Linear(15972, 64)
        self.fc2 = nn.Linear(64, 1) # 1 for binary classification
        self.relu = nn.LeakyReLU()
        self.batch=nn.BatchNorm1d(64)
        self.drop=nn.Dropout(p=0.5)        
        
    def _conv_layer_set(self, in_c, out_c):
        conv_layer = nn.Sequential(
        nn.Conv3d(in_c, out_c, 3, stride=1, padding=1, padding_mode="zeros"),
        nn.LeakyReLU(),
        nn.MaxPool3d((3, 3, 3)),
        )
        return conv_layer
    

    def forward(self, x):
        # Set 1
        out = self.conv_layer1(x)
        out = self.conv_layer2(out)
        out = out.view(out.size(0), -1)
        out = self.fc1(out)
        out = self.relu(out)
        out = self.batch(out)
        out = self.drop(out)
        out = self.fc2(out)
        
        return out

      
#Definition of hyperparameters
num_epochs = 5

# Create CNN
model = CNNModel()
# model.cuda()

# Cross Entropy Loss 
error =  nn.BCEWithLogitsLoss()

# SGD Optimizer
optimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)

# CNN model training
loss_list = []
test_accuracy_list = []
train_accuracy_list = []
stime = time.time()
for epoch in range(num_epochs):
    for i, (train, labels) in enumerate(train_loader):
        
        
        # Clear gradients
        optimizer.zero_grad()
        
        # Forward propagation
        outputs = model(train)
        
        # Calculate softmax and ross entropy loss
        loss = error(outputs, labels)
        
        
        # Calculating gradients
        loss.backward()
        
        # Update parameters
        optimizer.step()
        
            
    
    # Iterate through training dataset
    y_pred = []
    y_true = []
    with torch.no_grad():
      for images, labels in train_loader:

          # Forward propagation
          outputs = model(images)

          # Get predictions

          predicted = torch.round(torch.sigmoid(outputs))

          # Collect prediction and ground truth
          y_pred += predicted.detach().numpy().flatten().tolist()
          y_true += labels.flatten().numpy().tolist()

      train_accuracy = round(accuracy_score(y_true, y_pred), 2)

    
    # Iterate through test dataset
    y_pred = []
    y_true = []
    with torch.no_grad():
      for images, labels in test_loader:

          # Forward propagation
          outputs = model(images)

          # Get predictions
          predicted = torch.round(torch.sigmoid(outputs))

          # Collect prediction and ground truth
          y_pred += predicted.detach().numpy().flatten().tolist()
          y_true += labels.flatten().numpy().tolist()

    test_accuracy = round(accuracy_score(y_true, y_pred), 2)


    # store loss and iteration
    loss_list.append(loss.data)
    train_accuracy_list.append(train_accuracy)
    test_accuracy_list.append(test_accuracy)

    print('Epoch: {}  Train Loss: {}  Train Acc.: {} Test Acc.: {}'.format(epoch, loss.data, train_accuracy, test_accuracy))

etime = time.time()
dtime = etime-stime

print(f"For {num_epochs} it took {dtime/60} minutes")
